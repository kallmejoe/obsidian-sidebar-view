/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/node-pages/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NodePagesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  nodeTypes: [
    {
      tag: "task",
      displayName: "Task",
      icon: "check-square",
      color: "#7c3aed",
      properties: [
        { name: "status", type: "select", options: ["todo", "in-progress", "done"], default: "todo" },
        { name: "priority", type: "select", options: ["low", "medium", "high"], default: "medium" },
        { name: "due", type: "date" },
        { name: "assignee", type: "text" }
      ]
    },
    {
      tag: "project",
      displayName: "Project",
      icon: "folder",
      color: "#2563eb",
      properties: [
        { name: "status", type: "select", options: ["planning", "active", "completed", "archived"], default: "planning" },
        { name: "category", type: "text" },
        { name: "progress", type: "text" },
        { name: "deadline", type: "date" }
      ]
    },
    {
      tag: "note",
      displayName: "Note",
      icon: "file-text",
      color: "#059669",
      properties: [
        { name: "category", type: "text" },
        { name: "created", type: "date" }
      ]
    }
  ],
  defaultExpanded: false,
  showNodeHeader: true
};
var NodePagesPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.loadStyles();
    this.addSettingTab(new NodePagesSettingTab(this.app, this));
    this.registerMarkdownPostProcessor((el, ctx) => {
      this.processNodeHeader(el, ctx);
    });
    this.addCommand({
      id: "create-node-page",
      name: "Create new node page",
      callback: () => {
        new CreateNodeModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "toggle-node-expanded",
      name: "Toggle node expanded/collapsed",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view) {
          if (!checking) {
            this.toggleNodeExpanded(view);
          }
          return true;
        }
        return false;
      }
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.refreshActiveView();
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian.TFile) {
          this.refreshActiveView();
        }
      })
    );
    console.log("Node Pages plugin loaded");
  }
  onunload() {
    if (this.styleEl) {
      this.styleEl.remove();
    }
    console.log("Node Pages plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getNodeTypeForTags(tags) {
    for (const tag of tags) {
      const cleanTag = tag.replace(/^#/, "").toLowerCase();
      const nodeType = this.settings.nodeTypes.find(
        (nt) => nt.tag.toLowerCase() === cleanTag
      );
      if (nodeType)
        return nodeType;
    }
    return null;
  }
  refreshActiveView() {
    var _a;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view && view.file) {
      (_a = view.previewMode) == null ? void 0 : _a.rerender(true);
    }
  }
  toggleNodeExpanded(view) {
    const container = view.containerEl.querySelector(".node-page-header");
    if (container) {
      container.classList.toggle("is-expanded");
    }
  }
  async processNodeHeader(el, ctx) {
    var _a, _b;
    const file = this.app.vault.getAbstractFileByPath(ctx.sourcePath);
    if (!(file instanceof import_obsidian.TFile))
      return;
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache)
      return;
    let tags = [];
    if (cache.frontmatter && cache.frontmatter.tags) {
      const fmTags = cache.frontmatter.tags;
      tags = Array.isArray(fmTags) ? fmTags.map((t) => String(t)) : [String(fmTags)];
    } else if (cache.tags && Array.isArray(cache.tags)) {
      tags = cache.tags.map((t) => typeof t === "string" ? t : t.tag).filter(Boolean);
    } else {
      try {
        const content = await this.app.vault.read(file);
        const re = /(^|\s)#([A-Za-z0-9/_-]+)/g;
        const found = [];
        for (const m of content.matchAll(re)) {
          if (m[2])
            found.push(m[2]);
        }
        tags = found;
      } catch (e) {
        tags = [];
      }
    }
    const normalizedTags = tags.map((t) => String(t));
    console.log("NodePages: detected tags for", file.path, normalizedTags);
    const nodeType = this.getNodeTypeForTags(normalizedTags);
    console.log("NodePages: matched nodeType for", file.path, nodeType && nodeType.tag);
    if (!nodeType)
      return;
    const isFirstElement = ((_a = el.parentElement) == null ? void 0 : _a.firstElementChild) === el;
    if (!isFirstElement)
      return;
    const existingHeader = (_b = el.parentElement) == null ? void 0 : _b.querySelector(".node-page-header");
    if (existingHeader)
      return;
    const nodeHeader = this.createNodeHeader(file, nodeType, cache.frontmatter || {});
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (activeView && activeView.file && activeView.file.path === file.path) {
        const previewRoot = activeView.containerEl.querySelector(".markdown-preview-section") || activeView.containerEl.querySelector(".markdown-preview-view") || activeView.containerEl.querySelector(".markdown-preview");
        if (previewRoot && previewRoot.parentElement) {
          const existing = previewRoot.parentElement.querySelector(".node-page-header");
          if (!existing) {
            previewRoot.parentElement.insertBefore(nodeHeader, previewRoot);
            console.log(`NodePages: inserted header for ${file.path} into active preview root`);
            return;
          }
        }
      }
    } catch (e) {
    }
    const parent = el.parentElement;
    if (parent) {
      const existingHeader2 = parent.querySelector(".node-page-header");
      if (!existingHeader2)
        parent.insertBefore(nodeHeader, parent.firstChild);
      else
        console.log(`NodePages: header already exists for ${file.path}`);
    } else {
      console.log(`NodePages: could not find insertion point for ${file.path}`);
    }
  }
  createNodeHeader(file, nodeType, frontmatter) {
    const container = document.createElement("div");
    container.className = "node-page-header";
    if (this.settings.defaultExpanded) {
      container.classList.add("is-expanded");
    }
    container.style.setProperty("--node-color", nodeType.color || "#6366f1");
    const headerBar = container.createDiv("node-header-bar");
    const toggleBtn = headerBar.createDiv("node-toggle-btn");
    (0, import_obsidian.setIcon)(toggleBtn, "chevron-right");
    toggleBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      container.classList.toggle("is-expanded");
    });
    const iconEl = headerBar.createDiv("node-type-icon");
    (0, import_obsidian.setIcon)(iconEl, nodeType.icon);
    const titleEl = headerBar.createDiv("node-title");
    titleEl.textContent = file.basename;
    const badgeEl = headerBar.createDiv("node-type-badge");
    badgeEl.textContent = nodeType.displayName;
    const quickStatus = headerBar.createDiv("node-quick-status");
    this.renderQuickStatus(quickStatus, nodeType, frontmatter);
    const propertiesPanel = container.createDiv("node-properties-panel");
    this.renderPropertiesPanel(propertiesPanel, file, nodeType, frontmatter);
    return container;
  }
  renderQuickStatus(container, nodeType, frontmatter) {
    container.empty();
    const importantProps = nodeType.properties.slice(0, 3);
    for (const prop of importantProps) {
      const value = frontmatter[prop.name];
      if (value !== void 0 && value !== null && value !== "") {
        const propEl = container.createSpan("node-quick-prop");
        propEl.createSpan({ cls: "node-quick-prop-name", text: prop.name + ":" });
        propEl.createSpan({ cls: "node-quick-prop-value", text: String(value) });
      }
    }
  }
  renderPropertiesPanel(container, file, nodeType, frontmatter) {
    container.empty();
    for (const prop of nodeType.properties) {
      const propRow = container.createDiv("node-property-row");
      const labelEl = propRow.createDiv("node-property-label");
      labelEl.textContent = prop.name;
      const valueEl = propRow.createDiv("node-property-value");
      this.renderPropertyEditor(valueEl, file, prop, frontmatter[prop.name]);
    }
  }
  renderPropertyEditor(container, file, prop, value) {
    const updateProperty = async (newValue) => {
      await this.updateFileProperty(file, prop.name, newValue);
    };
    switch (prop.type) {
      case "text":
        const textInput = document.createElement("input");
        textInput.type = "text";
        textInput.className = "node-property-input";
        textInput.value = value || "";
        textInput.placeholder = `Enter ${prop.name}...`;
        textInput.addEventListener("change", () => updateProperty(textInput.value));
        textInput.addEventListener("blur", () => updateProperty(textInput.value));
        container.appendChild(textInput);
        break;
      case "number":
        const numInput = document.createElement("input");
        numInput.type = "number";
        numInput.className = "node-property-input";
        numInput.value = value || "";
        numInput.addEventListener("change", () => updateProperty(Number(numInput.value)));
        container.appendChild(numInput);
        break;
      case "date":
        const dateInput = document.createElement("input");
        dateInput.type = "date";
        dateInput.className = "node-property-input";
        if (value) {
          const date = new Date(value);
          if (!isNaN(date.getTime())) {
            dateInput.value = date.toISOString().split("T")[0];
          }
        }
        dateInput.addEventListener("change", () => updateProperty(dateInput.value));
        container.appendChild(dateInput);
        break;
      case "checkbox":
        const checkInput = document.createElement("input");
        checkInput.type = "checkbox";
        checkInput.className = "node-property-checkbox";
        checkInput.checked = Boolean(value);
        checkInput.addEventListener("change", () => updateProperty(checkInput.checked));
        container.appendChild(checkInput);
        break;
      case "select":
        const selectEl = document.createElement("select");
        selectEl.className = "node-property-select";
        const emptyOpt = document.createElement("option");
        emptyOpt.value = "";
        emptyOpt.textContent = `Select ${prop.name}...`;
        selectEl.appendChild(emptyOpt);
        for (const opt of prop.options || []) {
          const optEl = document.createElement("option");
          optEl.value = opt;
          optEl.textContent = opt;
          if (value === opt)
            optEl.selected = true;
          selectEl.appendChild(optEl);
        }
        selectEl.addEventListener("change", () => updateProperty(selectEl.value));
        container.appendChild(selectEl);
        break;
    }
  }
  async updateFileProperty(file, propertyName, value) {
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    let fmStart = -1;
    let fmEnd = -1;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim() === "---") {
        if (fmStart === -1) {
          fmStart = i;
        } else {
          fmEnd = i;
          break;
        }
      }
    }
    if (fmStart === -1 || fmEnd === -1) {
      new import_obsidian.Notice("Could not find frontmatter in file");
      return;
    }
    let propertyFound = false;
    for (let i = fmStart + 1; i < fmEnd; i++) {
      const line = lines[i];
      const match = line.match(/^(\s*)([^:]+):\s*(.*)$/);
      if (match && match[2].trim() === propertyName) {
        let formattedValue = value;
        if (typeof value === "string" && value.includes(":")) {
          formattedValue = `"${value}"`;
        }
        lines[i] = `${match[1]}${propertyName}: ${formattedValue}`;
        propertyFound = true;
        break;
      }
    }
    if (!propertyFound) {
      let formattedValue = value;
      if (typeof value === "string" && value.includes(":")) {
        formattedValue = `"${value}"`;
      }
      lines.splice(fmEnd, 0, `${propertyName}: ${formattedValue}`);
    }
    await this.app.vault.modify(file, lines.join("\n"));
  }
  loadStyles() {
    this.styleEl = document.createElement("style");
    this.styleEl.id = "node-pages-styles";
    this.styleEl.textContent = `
      /* Node Page Header Container */
      .node-page-header {
        --node-color: #6366f1;
        margin: 0 0 16px 0;
        border-radius: 8px;
        border: 1px solid var(--background-modifier-border);
        background: var(--background-secondary);
        overflow: hidden;
        transition: all 0.2s ease;
      }

      .node-page-header:hover {
        border-color: var(--node-color);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      /* Header Bar - Always Visible */
      .node-header-bar {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 16px;
        cursor: pointer;
        user-select: none;
      }

      .node-header-bar:hover {
        background: var(--background-modifier-hover);
      }

      /* Toggle Button */
      .node-toggle-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        border-radius: 4px;
        color: var(--text-muted);
        transition: all 0.15s ease;
        flex-shrink: 0;
      }

      .node-toggle-btn:hover {
        background: var(--background-modifier-hover);
        color: var(--text-normal);
      }

      .node-page-header.is-expanded .node-toggle-btn {
        transform: rotate(90deg);
      }

      /* Type Icon */
      .node-type-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 6px;
        background: var(--node-color);
        color: white;
        flex-shrink: 0;
      }

      .node-type-icon svg {
        width: 16px;
        height: 16px;
      }

      /* Title */
      .node-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-normal);
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* Type Badge */
      .node-type-badge {
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        padding: 2px 8px;
        border-radius: 4px;
        background: var(--node-color);
        color: white;
        flex-shrink: 0;
      }

      /* Quick Status (collapsed view) */
      .node-quick-status {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-left: auto;
        flex-shrink: 0;
      }

      .node-page-header.is-expanded .node-quick-status {
        display: none;
      }

      .node-quick-prop {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 12px;
      }

      .node-quick-prop-name {
        color: var(--text-muted);
      }

      .node-quick-prop-value {
        color: var(--text-normal);
        font-weight: 500;
      }

      /* Properties Panel (expanded view) */
      .node-properties-panel {
        display: none;
        padding: 0 16px 16px 16px;
        border-top: 1px solid var(--background-modifier-border);
        background: var(--background-primary);
      }

      .node-page-header.is-expanded .node-properties-panel {
        display: block;
      }

      /* Property Row */
      .node-property-row {
        display: flex;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid var(--background-modifier-border);
      }

      .node-property-row:last-child {
        border-bottom: none;
      }

      .node-property-label {
        width: 120px;
        font-size: 13px;
        font-weight: 500;
        color: var(--text-muted);
        text-transform: capitalize;
        flex-shrink: 0;
      }

      .node-property-value {
        flex: 1;
      }

      /* Property Inputs */
      .node-property-input,
      .node-property-select {
        width: 100%;
        padding: 6px 10px;
        font-size: 13px;
        border: 1px solid var(--background-modifier-border);
        border-radius: 4px;
        background: var(--background-primary);
        color: var(--text-normal);
        transition: border-color 0.15s ease;
      }

      .node-property-input:focus,
      .node-property-select:focus {
        outline: none;
        border-color: var(--node-color);
        box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
      }

      .node-property-input::placeholder {
        color: var(--text-faint);
      }

      .node-property-checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--node-color);
      }

      /* Hide default frontmatter when node header is present */
      .node-page-header ~ .frontmatter,
      .node-page-header ~ .frontmatter-container {
        display: none !important;
      }
    `;
    document.head.appendChild(this.styleEl);
  }
};
var CreateNodeModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.selectedType = null;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("node-create-modal");
    contentEl.createEl("h2", { text: "Create New Node Page" });
    new import_obsidian.Setting(contentEl).setName("Title").addText((text) => {
      this.titleInput = text;
      text.setPlaceholder("Enter page title...");
    });
    new import_obsidian.Setting(contentEl).setName("Type").addDropdown((dropdown) => {
      dropdown.addOption("", "Select type...");
      for (const nodeType of this.plugin.settings.nodeTypes) {
        dropdown.addOption(nodeType.tag, nodeType.displayName);
      }
      dropdown.onChange((value) => {
        this.selectedType = this.plugin.settings.nodeTypes.find(
          (nt) => nt.tag === value
        ) || null;
      });
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Create").setCta().onClick(async () => {
        await this.createNodePage();
      });
    });
  }
  async createNodePage() {
    const title = this.titleInput.getValue().trim();
    if (!title) {
      new import_obsidian.Notice("Please enter a title");
      return;
    }
    if (!this.selectedType) {
      new import_obsidian.Notice("Please select a type");
      return;
    }
    const properties = [
      "---",
      "tags:",
      `  - ${this.selectedType.tag}`
    ];
    for (const prop of this.selectedType.properties) {
      let defaultValue = prop.default !== void 0 ? prop.default : "";
      if (prop.type === "date" && !defaultValue) {
        defaultValue = new Date().toISOString().split("T")[0];
      }
      properties.push(`${prop.name}: ${defaultValue}`);
    }
    properties.push("---");
    properties.push("");
    properties.push(`# ${title}`);
    properties.push("");
    const content = properties.join("\n");
    const fileName = `${title}.md`;
    try {
      const file = await this.app.vault.create(fileName, content);
      await this.app.workspace.getLeaf().openFile(file);
      this.close();
      new import_obsidian.Notice(`Created ${this.selectedType.displayName}: ${title}`);
    } catch (e) {
      new import_obsidian.Notice(`Failed to create file: ${e.message}`);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var NodePagesSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Node Pages Settings" });
    new import_obsidian.Setting(containerEl).setName("Default expanded").setDesc("Whether node headers are expanded by default").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.defaultExpanded);
      toggle.onChange(async (value) => {
        this.plugin.settings.defaultExpanded = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Node Types" });
    containerEl.createEl("p", {
      text: "Configure which tags map to node types and their properties.",
      cls: "setting-item-description"
    });
    for (const nodeType of this.plugin.settings.nodeTypes) {
      this.renderNodeTypeSettings(containerEl, nodeType);
    }
    new import_obsidian.Setting(containerEl).addButton((btn) => {
      btn.setButtonText("Add Node Type").onClick(async () => {
        const newType = {
          tag: "new-type",
          displayName: "New Type",
          icon: "file",
          properties: []
        };
        this.plugin.settings.nodeTypes.push(newType);
        await this.plugin.saveSettings();
        this.display();
      });
    });
  }
  renderNodeTypeSettings(container, nodeType) {
    const typeContainer = container.createDiv("node-type-settings");
    typeContainer.style.padding = "12px";
    typeContainer.style.marginBottom = "12px";
    typeContainer.style.border = "1px solid var(--background-modifier-border)";
    typeContainer.style.borderRadius = "8px";
    new import_obsidian.Setting(typeContainer).setName("Tag").setDesc("The tag that identifies this node type (without #)").addText((text) => {
      text.setValue(nodeType.tag);
      text.onChange(async (value) => {
        nodeType.tag = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(typeContainer).setName("Display Name").addText((text) => {
      text.setValue(nodeType.displayName);
      text.onChange(async (value) => {
        nodeType.displayName = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(typeContainer).setName("Icon").setDesc("Lucide icon name").addText((text) => {
      text.setValue(nodeType.icon);
      text.onChange(async (value) => {
        nodeType.icon = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(typeContainer).setName("Color").addText((text) => {
      text.setValue(nodeType.color || "#6366f1");
      text.onChange(async (value) => {
        nodeType.color = value;
        await this.plugin.saveSettings();
      });
    });
    const propsHeader = typeContainer.createDiv();
    propsHeader.style.display = "flex";
    propsHeader.style.justifyContent = "space-between";
    propsHeader.style.alignItems = "center";
    propsHeader.style.marginTop = "12px";
    propsHeader.createEl("strong", { text: "Properties" });
    const addPropBtn = propsHeader.createEl("button", { text: "+ Add Property" });
    addPropBtn.addEventListener("click", async () => {
      nodeType.properties.push({
        name: "new-property",
        type: "text"
      });
      await this.plugin.saveSettings();
      this.display();
    });
    for (let i = 0; i < nodeType.properties.length; i++) {
      const prop = nodeType.properties[i];
      this.renderPropertySettings(typeContainer, nodeType, prop, i);
    }
    new import_obsidian.Setting(typeContainer).addButton((btn) => {
      btn.setButtonText("Delete Type").setWarning().onClick(async () => {
        const index = this.plugin.settings.nodeTypes.indexOf(nodeType);
        if (index > -1) {
          this.plugin.settings.nodeTypes.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        }
      });
    });
  }
  renderPropertySettings(container, nodeType, prop, index) {
    const propRow = container.createDiv();
    propRow.style.display = "flex";
    propRow.style.gap = "8px";
    propRow.style.alignItems = "center";
    propRow.style.marginTop = "8px";
    propRow.style.paddingLeft = "16px";
    const nameInput = propRow.createEl("input", { type: "text" });
    nameInput.value = prop.name;
    nameInput.placeholder = "Property name";
    nameInput.style.flex = "1";
    nameInput.addEventListener("change", async () => {
      prop.name = nameInput.value;
      await this.plugin.saveSettings();
    });
    const typeSelect = propRow.createEl("select");
    ["text", "number", "date", "checkbox", "select"].forEach((t) => {
      const opt = typeSelect.createEl("option", { value: t, text: t });
      if (prop.type === t)
        opt.selected = true;
    });
    typeSelect.addEventListener("change", async () => {
      prop.type = typeSelect.value;
      await this.plugin.saveSettings();
      this.display();
    });
    if (prop.type === "select") {
      const optionsInput = propRow.createEl("input", { type: "text" });
      optionsInput.value = (prop.options || []).join(", ");
      optionsInput.placeholder = "Options (comma-separated)";
      optionsInput.style.flex = "1";
      optionsInput.addEventListener("change", async () => {
        prop.options = optionsInput.value.split(",").map((s) => s.trim()).filter(Boolean);
        await this.plugin.saveSettings();
      });
    }
    const deleteBtn = propRow.createEl("button", { text: "x" });
    deleteBtn.style.padding = "2px 8px";
    deleteBtn.addEventListener("click", async () => {
      nodeType.properties.splice(index, 1);
      await this.plugin.saveSettings();
      this.display();
    });
  }
};
